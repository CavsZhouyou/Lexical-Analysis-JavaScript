{"version":3,"sources":["../src/lexicalAnalysis.js"],"names":["maps","fs","require","DOCUMENT_PATH","BUFFER_LENGTH","identifier","buffer","start","end","state","results","isSearching","console","log","open","err","fd","error","BufferStorage","charter","getCharacter","nextIndex","match","BASE","OFFSET_MAP","get","CHECK","isFileEnd","NEXT","token","getString","result","type","value","push","STATE_MAP","parseInt","DEFAULT","showResult","forEach"],"mappings":";;AAaA;;;;AACA;;IAAYA,I;;;;;;AAAoB;AAdhC;;;;;;;;;AAUA;;;AAKA,IAAIC,KAAKC,QAAQ,IAAR,CAAT,C,CAAwB;;;AAGxB;;;AAL6C;AAQ7C,IAAMC,gBAAgB,qBAAtB;AAAA,IAA6C;AAC3CC,gBAAgB,EADlB,C,CACsB;;;AAGtB;;;AAGA,IAAIC,aAAa,EAAjB;AAAA,IAAqB;AACnBC,SAAS,IADX;AAAA,IACiB;AACfC,QAAQ,CAFV;AAAA,IAGEC,MAAM,CAHR;AAAA,IAIEC,QAAQ,CAJV;AAAA,IAIa;AACXC,UAAU,EALZ;AAAA,IAKgB;AACdC,cAAc,IANhB;;AASA;;;AAGAC,QAAQC,GAAR,CAAY,gBAAgBV,aAA5B;AACAF,GAAGa,IAAH,CAAQX,aAAR,EAAuB,IAAvB,EAA6B,UAAUY,GAAV,EAAeC,EAAf,EAAmB;;AAE9C;AACA,MAAID,GAAJ,EAAS;AACP,WAAOH,QAAQK,KAAR,CAAcF,GAAd,CAAP;AACD;;AAEDH,UAAQC,GAAR,CAAY,SAAZ;AACAD,UAAQC,GAAR,CAAY,eAAZ;;AAEAP,WAAS,IAAIY,uBAAJ,CAAkBF,EAAlB,EAAsBZ,aAAtB,CAAT;;AAEA,KAAG;AACD,QAAI,CAACO,WAAL,EAAkB;AAChBH;AACAG,oBAAc,IAAd;AACD;AACD,QAAIQ,UAAUb,OAAOc,YAAP,CAAoBZ,GAApB,CAAd;AAAA,QACEa,YAAY,CADd;;AAGA;AACA;AACA;AACA;;AAEA;AACA,QAAIF,QAAQG,KAAR,CAAc,UAAd,CAAJ,EAA+B;AAC7BD,kBAAYrB,KAAKuB,IAAL,CAAUd,KAAV,IAAmBT,KAAKwB,UAAL,CAAgBC,GAAhB,CAAoB,OAApB,CAA/B;AACD,KAFD,MAEO,IAAIN,QAAQG,KAAR,CAAc,aAAd,CAAJ,EAAkC;AACvCD,kBAAYrB,KAAKuB,IAAL,CAAUd,KAAV,IAAmBT,KAAKwB,UAAL,CAAgBC,GAAhB,CAAoB,QAApB,CAA/B;AACD,KAFM,MAEA,IAAIN,QAAQG,KAAR,CAAc,QAAd,KAA2BH,QAAQG,KAAR,CAAc,QAAd,CAA/B,EAAwD;AAC7DD,kBAAYrB,KAAKuB,IAAL,CAAUd,KAAV,IAAmBT,KAAKwB,UAAL,CAAgBC,GAAhB,CAAoB,OAApB,CAA/B;AACD,KAFM,MAEA;AACLJ,kBAAYrB,KAAKuB,IAAL,CAAUd,KAAV,IAAmBT,KAAKwB,UAAL,CAAgBC,GAAhB,CAAoBN,OAApB,CAA/B;AACD;;AAED,QAAInB,KAAK0B,KAAL,CAAWL,SAAX,MAA0B,EAA1B,IAAgCrB,KAAK0B,KAAL,CAAWL,SAAX,MAA0BZ,KAA1D,IAAmE,CAACH,OAAOqB,SAAP,CAAiBnB,MAAM,CAAvB,CAAxE,EAAmG;AACjGC,cAAQT,KAAK4B,IAAL,CAAUP,SAAV,CAAR;AACA;AACD,KAHD,MAGO;AACL,UAAIQ,QAAQvB,OAAOwB,SAAP,CAAiBvB,KAAjB,EAAwBC,GAAxB,CAAZ;AAAA,UACEuB,SAAS;AACPC,cAAM,EADC;AAEPC,eAAO;AAFA,OADX;;AAMArB,cAAQC,GAAR,CAAYN,KAAZ,EAAmBC,GAAnB;;AAEA,cAAQC,KAAR;AACE,aAAK,CAAL;AAAQ;AACNJ,qBAAW6B,IAAX,CAAgBL,KAAhB;AACA,cAAI7B,KAAKmC,SAAL,CAAeV,GAAf,CAAmBI,KAAnB,CAAJ,EAA+B;AAC7BE,mBAAOC,IAAP,GAAchC,KAAKmC,SAAL,CAAeV,GAAf,CAAmBI,KAAnB,CAAd;AACAE,mBAAOE,KAAP,GAAeJ,KAAf;AACD,WAHD,MAGO;AACLE,mBAAOC,IAAP,GAAchC,KAAKmC,SAAL,CAAeV,GAAf,CAAmB,YAAnB,CAAd;AACAM,mBAAOE,KAAP,GAAeJ,KAAf;AACD;AACD;AACF,aAAK,CAAL;AAAQ;AACNE,iBAAOC,IAAP,GAAchC,KAAKmC,SAAL,CAAeV,GAAf,CAAmB,KAAnB,CAAd;AACAM,iBAAOE,KAAP,GAAeG,SAASP,KAAT,CAAf;AACA;AACF,aAAK,EAAL;AACE;AACF;AACE,cAAI7B,KAAKmC,SAAL,CAAeV,GAAf,CAAmBI,KAAnB,CAAJ,EAA+B;AAC7BE,mBAAOC,IAAP,GAAchC,KAAKmC,SAAL,CAAeV,GAAf,CAAmBI,KAAnB,CAAd;AACAE,mBAAOE,KAAP,GAAeJ,KAAf;AACD;AArBL;;AAwBA,UAAIE,OAAOC,IAAX,EAAiB;AACftB,gBAAQwB,IAAR,CAAaH,MAAb;AACD;;AAEDtB,cAAQT,KAAKqC,OAAL,CAAa5B,KAAb,CAAR;AACAF,cAAQC,GAAR;AACAG,oBAAc,KAAd;AACD;AAEF,GArED,QAsEO,CAACL,OAAOqB,SAAP,CAAiB,EAAEnB,GAAnB,CAtER;AAuEA8B,aAAW5B,OAAX;AACD,CApFD;;AAsFA;AACA,SAAS4B,UAAT,CAAoB5B,OAApB,EAA6B;AAC3BA,UAAQ6B,OAAR,CAAgB,iBAAS;AACvB3B,YAAQC,GAAR,CAAY,MAAMgB,MAAMG,IAAZ,GAAmB,GAAnB,GAAyBH,MAAMI,KAA/B,GAAuC,GAAnD;AACD,GAFD;AAGD","file":"lexicalAnalysis.js","sourcesContent":["/*\r\n * @Author: zhouyou@werun \r\n * @Descriptions: js 实现 c 语言的词法分析器\r\n * @TodoList: 无\r\n * @Date: 2018-10-20 18:46:33 \r\n * @Last Modified by: zhouyou@werun\r\n * @Last Modified time: 2018-10-25 09:33:49\r\n */\r\n\r\n\r\n/**\r\n * 依赖模块引入\r\n */\r\nimport BufferStorage from './BufferStorage'; // 引入 BufferStorage 缓存区操作类\r\nimport * as maps from './maps'; // 引入字符偏移量映射表\r\nlet fs = require(\"fs\"); // 引入文件模块依赖\r\n\r\n\r\n/**\r\n * 常量定义\r\n */\r\nconst DOCUMENT_PATH = \"./document/test.txt\", // 源文件路径\r\n  BUFFER_LENGTH = 10; // 缓存区长度\r\n\r\n\r\n/**\r\n * 全局变量定义\r\n */\r\nlet identifier = [], // 标识符识别表\r\n  buffer = null, // 缓存区\r\n  start = 0,\r\n  end = 0,\r\n  state = 0, // 状态机状态\r\n  results = [], // 存放结果数组\r\n  isSearching = true;\r\n\r\n\r\n/**\r\n * 打开并处理文件\r\n */\r\nconsole.log(\"准备打开已存在的文件：\" + DOCUMENT_PATH);\r\nfs.open(DOCUMENT_PATH, 'r+', function (err, fd) {\r\n\r\n  // 错误处理\r\n  if (err) {\r\n    return console.error(err);\r\n  }\r\n\r\n  console.log(\"文件打开成功！\");\r\n  console.log(\"开始对源文件进行词法分析！\");\r\n\r\n  buffer = new BufferStorage(fd, BUFFER_LENGTH);\r\n\r\n  do {\r\n    if (!isSearching) {\r\n      end--;\r\n      isSearching = true;\r\n    }\r\n    let charter = buffer.getCharacter(end),\r\n      nextIndex = 0;\r\n\r\n    // // 处理空格、换行符等情况\r\n    // if (charter.match(/^[ ]+$/) || charter.match(/[\\r\\n]/)) {\r\n    //   continue;\r\n    // }\r\n\r\n    // 获取 next 映射表中的索引值\r\n    if (charter.match(/^[0-9]*$/)) {\r\n      nextIndex = maps.BASE[state] + maps.OFFSET_MAP.get(\"digit\");\r\n    } else if (charter.match(/^[A-Za-z]+$/)) {\r\n      nextIndex = maps.BASE[state] + maps.OFFSET_MAP.get(\"letter\");\r\n    } else if (charter.match(/^[ ]+$/) || charter.match(/[\\r\\n]/)) {\r\n      nextIndex = maps.BASE[state] + maps.OFFSET_MAP.get(\"space\");\r\n    } else {\r\n      nextIndex = maps.BASE[state] + maps.OFFSET_MAP.get(charter);\r\n    }\r\n\r\n    if (maps.CHECK[nextIndex] !== \"\" && maps.CHECK[nextIndex] === state && !buffer.isFileEnd(end + 1)) {\r\n      state = maps.NEXT[nextIndex];\r\n      continue;\r\n    } else {\r\n      let token = buffer.getString(start, end),\r\n        result = {\r\n          type: \"\",\r\n          value: \"\",\r\n        }\r\n\r\n      console.log(start, end);\r\n\r\n      switch (state) {\r\n        case 1: // 处理标识符的情况\r\n          identifier.push(token);\r\n          if (maps.STATE_MAP.get(token)) {\r\n            result.type = maps.STATE_MAP.get(token);\r\n            result.value = token;\r\n          } else {\r\n            result.type = maps.STATE_MAP.get(\"identifier\");\r\n            result.value = token;\r\n          }\r\n          break;\r\n        case 2: // 处理整数的情况\r\n          result.type = maps.STATE_MAP.get(\"int\");\r\n          result.value = parseInt(token);\r\n          break;\r\n        case 18:\r\n          break;\r\n        default:\r\n          if (maps.STATE_MAP.get(token)) {\r\n            result.type = maps.STATE_MAP.get(token);\r\n            result.value = token;\r\n          }\r\n      }\r\n\r\n      if (result.type) {\r\n        results.push(result);\r\n      }\r\n\r\n      state = maps.DEFAULT[state];\r\n      start = end;\r\n      isSearching = false;\r\n    }\r\n\r\n  }\r\n  while (!buffer.isFileEnd(++end))\r\n  showResult(results);\r\n});\r\n\r\n// console.log(results[0].type);\r\nfunction showResult(results) {\r\n  results.forEach(token => {\r\n    console.log(\"(\" + token.type + \",\" + token.value + \")\")\r\n  });\r\n}"]}