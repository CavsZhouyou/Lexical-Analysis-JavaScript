{"version":3,"sources":["../src/lexicalAnalysis.js"],"names":["maps","fs","require","DOCUMENT_PATH","BUFFER_LENGTH","identifier","buffer","start","end","state","results","console","log","open","err","fd","error","BufferStorage","charter","getCharacter","nextIndex","match","BASE","OFFSET_MAP","get","CHECK","isFileEnd","NEXT","token","getString","result","type","value","push","STATE_MAP","parseInt","DEFAULT","showResult","forEach"],"mappings":"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","file":"lexicalAnalysis.js","sourcesContent":["/*\r\n * @Author: zhouyou@werun \r\n * @Descriptions: js 实现 c 语言的词法分析器\r\n * @TodoList: 无\r\n * @Date: 2018-10-20 18:46:33 \r\n * @Last Modified by: zhouyou@werun\r\n * @Last Modified time: 2018-10-24 22:50:51\r\n */\r\n\r\n\r\n/**\r\n * 依赖模块引入\r\n */\r\nimport BufferStorage from './BufferStorage'; // 引入 BufferStorage 缓存区操作类\r\nimport * as maps from './maps'; // 引入字符偏移量映射表\r\nlet fs = require(\"fs\"); // 引入文件模块依赖\r\n\r\n\r\n/**\r\n * 常量定义\r\n */\r\nconst DOCUMENT_PATH = \"./document/test.txt\", // 源文件路径\r\n  BUFFER_LENGTH = 10; // 缓存区长度\r\n\r\n\r\n/**\r\n * 全局变量定义\r\n */\r\nlet identifier = [], // 标识符识别表\r\n  buffer = null, // 缓存区\r\n  start = 0,\r\n  end = 0,\r\n  state = 0, // 状态机状态\r\n  results = []; // 存放结果数组\r\n\r\n\r\n/**\r\n * 打开并处理文件\r\n */\r\nconsole.log(\"准备打开已存在的文件：\" + DOCUMENT_PATH);\r\nfs.open(DOCUMENT_PATH, 'r+', function (err, fd) {\r\n\r\n  // 错误处理\r\n  if (err) {\r\n    return console.error(err);\r\n  }\r\n\r\n  console.log(\"文件打开成功！\");\r\n  console.log(\"开始对源文件进行词法分析！\");\r\n\r\n  buffer = new BufferStorage(fd, BUFFER_LENGTH);\r\n\r\n  do {\r\n    let charter = buffer.getCharacter(end),\r\n      nextIndex = 0;\r\n\r\n    // // 处理空格、换行符等情况\r\n    // if (charter.match(/^[ ]+$/) || charter.match(/[\\r\\n]/)) {\r\n    //   continue;\r\n    // }\r\n\r\n    // 获取 next 映射表中的索引值\r\n    if (charter.match(/^[0-9]*$/)) {\r\n      nextIndex = maps.BASE[state] + maps.OFFSET_MAP.get(\"digit\");\r\n    } else if (charter.match(/^[A-Za-z]+$/)) {\r\n      nextIndex = maps.BASE[state] + maps.OFFSET_MAP.get(\"letter\");\r\n    } else {\r\n      nextIndex = maps.BASE[state] + maps.OFFSET_MAP.get(charter);\r\n    }\r\n\r\n\r\n\r\n    if (maps.CHECK[nextIndex] !== \"\" && maps.CHECK[nextIndex] === state && !buffer.isFileEnd(end + 1)) {\r\n      state = maps.NEXT[nextIndex];\r\n      continue;\r\n    } else {\r\n      let token = buffer.getString(start, end),\r\n        result = {\r\n          type: \"\",\r\n          value: \"\",\r\n        }\r\n      console.log(token);\r\n      // 处理空格、换行符等情况\r\n      if (token.match(/^[ ]+$/) || token.match(/[\\r\\n]/)) {\r\n        start = end;\r\n        continue;\r\n      } else {\r\n        switch (state) {\r\n          case 1: // 处理标识符的情况\r\n            identifier.push(token);\r\n            if (maps.STATE_MAP.get(token)) {\r\n              result.type = maps.STATE_MAP.get(token);\r\n              result.value = token;\r\n            } else {\r\n              result.type = maps.STATE_MAP.get(\"identifier\");\r\n              result.value = token;\r\n            }\r\n            break;\r\n          case 2: // 处理整数的情况\r\n            result.type = maps.STATE_MAP.get(\"int\");\r\n            result.value = parseInt(token);\r\n            break;\r\n          default:\r\n            if (maps.STATE_MAP.get(token)) {\r\n              result.type = maps.STATE_MAP.get(token);\r\n              result.value = token;\r\n            }\r\n        }\r\n        state = maps.DEFAULT[state];\r\n        results.push(result);\r\n      }\r\n      start = end;\r\n    }\r\n\r\n  } while (!buffer.isFileEnd(++end))\r\n  showResult(results);\r\n});\r\n\r\n// console.log(results[0].type);\r\nfunction showResult(results) {\r\n  results.forEach(token => {\r\n    console.log(\"(\" + token.type + \",\" + token.value + \")\")\r\n  });\r\n}"]}