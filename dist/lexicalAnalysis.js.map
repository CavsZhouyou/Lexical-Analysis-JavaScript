{"version":3,"sources":["../src/lexicalAnalysis.js"],"names":["maps","fs","require","DOCUMENT_PATH","BUFFER_LENGTH","identifier","buffer","start","end","state","console","log","open","err","fd","error","BufferStorage","charter","getCharacter","nextIndex","match","BASE","OFFSET_MAP","get","CHECK","NEXT","token","getString","isFileEnd"],"mappings":";;AAaA;;;;AACA;;IAAYA,I;;;;;;AAAoB;AAdhC;;;;;;;;;AAUA;;;AAKA,IAAIC,KAAKC,QAAQ,IAAR,CAAT,C,CAAwB;;;AAGxB;;;AAL6C;AAQ7C,IAAMC,gBAAgB,qBAAtB;AAAA,IAA6C;AAC3CC,gBAAgB,EADlB,C,CACsB;;;AAGtB;;;AAGA,IAAIC,aAAa,EAAjB;AAAA,IAAqB;AACnBC,SAAS,IADX;AAAA,IACiB;AACfC,QAAQ,CAFV;AAAA,IAGEC,MAAM,CAHR;AAAA,IAIEC,QAAQ,CAJV,C,CAIa;;;AAGb;;;AAGAC,QAAQC,GAAR,CAAY,gBAAgBR,aAA5B;AACAF,GAAGW,IAAH,CAAQT,aAAR,EAAuB,IAAvB,EAA6B,UAAUU,GAAV,EAAeC,EAAf,EAAmB;;AAE9C;AACA,MAAID,GAAJ,EAAS;AACP,WAAOH,QAAQK,KAAR,CAAcF,GAAd,CAAP;AACD;;AAEDH,UAAQC,GAAR,CAAY,SAAZ;AACAD,UAAQC,GAAR,CAAY,eAAZ;;AAEAL,WAAS,IAAIU,uBAAJ,CAAkBF,EAAlB,EAAsBV,aAAtB,CAAT;;AAGA,KAAG;AACD,QAAIa,UAAUX,OAAOY,YAAP,CAAoBV,KAApB,CAAd;AAAA,QACEW,YAAY,CADd;;AAGA;AACA,QAAIF,QAAQG,KAAR,CAAc,QAAd,KAA2BH,QAAQG,KAAR,CAAc,QAAd,CAA/B,EAAwD;AACtD;AACD;;AAED;AACAD,gBAAYnB,KAAKqB,IAAL,CAAUZ,KAAV,IAAmBT,KAAKsB,UAAL,CAAgBC,GAAhB,CAAoBN,OAApB,CAA/B;;AAEA,QAAIjB,KAAKwB,KAAL,CAAWL,SAAX,KAAyBnB,KAAKwB,KAAL,CAAWL,SAAX,MAA0BV,KAAvD,EAA8D;AAC5DA,cAAQT,KAAKyB,IAAL,CAAUN,SAAV,CAAR;AACA;AACD,KAHD,MAGO;AACL,UAAIO,QAAQpB,OAAOqB,SAAP,CAAiBpB,KAAjB,EAAwBC,GAAxB,CAAZ;AACAE,cAAQC,GAAR,CAAYe,KAAZ;AACAnB,cAAQC,GAAR;AACD;AAGF,GAtBD,QAsBS,CAACF,OAAOsB,SAAP,CAAiBpB,GAAjB,CAtBV;AAyBD,CAtCD","file":"lexicalAnalysis.js","sourcesContent":["/*\r\n * @Author: zhouyou@werun \r\n * @Descriptions: js 实现 c 语言的词法分析器\r\n * @TodoList: 无\r\n * @Date: 2018-10-20 18:46:33 \r\n * @Last Modified by: zhouyou@werun\r\n * @Last Modified time: 2018-10-24 21:20:43\r\n */\r\n\r\n\r\n/**\r\n * 依赖模块引入\r\n */\r\nimport BufferStorage from './BufferStorage'; // 引入 BufferStorage 缓存区操作类\r\nimport * as maps from './maps'; // 引入字符偏移量映射表\r\nlet fs = require(\"fs\"); // 引入文件模块依赖\r\n\r\n\r\n/**\r\n * 常量定义\r\n */\r\nconst DOCUMENT_PATH = \"./document/test.txt\", // 源文件路径\r\n  BUFFER_LENGTH = 10; // 缓存区长度\r\n\r\n\r\n/**\r\n * 全局变量定义\r\n */\r\nlet identifier = [], // 标识符识别表\r\n  buffer = null, // 缓存区\r\n  start = 0,\r\n  end = 0,\r\n  state = 0; // 状态机状态\r\n\r\n\r\n/**\r\n * 打开并处理文件\r\n */\r\nconsole.log(\"准备打开已存在的文件：\" + DOCUMENT_PATH);\r\nfs.open(DOCUMENT_PATH, 'r+', function (err, fd) {\r\n\r\n  // 错误处理\r\n  if (err) {\r\n    return console.error(err);\r\n  }\r\n\r\n  console.log(\"文件打开成功！\");\r\n  console.log(\"开始对源文件进行词法分析！\");\r\n\r\n  buffer = new BufferStorage(fd, BUFFER_LENGTH);\r\n\r\n\r\n  do {\r\n    let charter = buffer.getCharacter(end++),\r\n      nextIndex = 0;\r\n\r\n    // 处理空格、换行符等情况\r\n    if (charter.match(/^[ ]+$/) || charter.match(/[\\r\\n]/)) {\r\n      continue;\r\n    }\r\n\r\n    // 获取 next 映射表中的索引值\r\n    nextIndex = maps.BASE[state] + maps.OFFSET_MAP.get(charter);\r\n\r\n    if (maps.CHECK[nextIndex] && maps.CHECK[nextIndex] === state) {\r\n      state = maps.NEXT[nextIndex];\r\n      continue;\r\n    } else {\r\n      let token = buffer.getString(start, end);\r\n      console.log(token);\r\n      start = end;\r\n    }\r\n\r\n\r\n  } while (!buffer.isFileEnd(end))\r\n\r\n\r\n});"]}