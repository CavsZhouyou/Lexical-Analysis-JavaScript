{"version":3,"sources":["../src/BufferStorage.js"],"names":["fs","require","BufferStorage","file","length","init","offset","position","buffer","Buffer","alloc","endFlag","bytes","readSync","index","toString"],"mappings":";;;;;;;;;;AAAA;;;;;;;;;AASA,IAAIA,KAAKC,QAAQ,IAAR,CAAT,C,CAAwB;;IAElBC,a;AAEJ,yBAAYC,IAAZ,EAAkBC,MAAlB,EAA0B;AAAA;;AACxB,SAAKC,IAAL,CAAUF,IAAV,EAAgBC,MAAhB;AACD;;AAED;;;;;;;;;;2BAM8B;AAAA,UAAzBD,IAAyB,uEAAlB,IAAkB;AAAA,UAAZC,MAAY,uEAAH,CAAG;;AAC5B,WAAKD,IAAL,GAAYA,IAAZ,CAD4B,CACV;AAClB,WAAKC,MAAL,GAAcA,MAAd,CAF4B,CAEN;AACtB,WAAKE,MAAL,GAAc,CAAd,CAH4B,CAGX;AACjB,WAAKC,QAAL,GAAgB,CAAhB,CAJ4B,CAIT;AACnB,WAAKC,MAAL,GAAc,IAAIC,OAAOC,KAAX,CAAiB,KAAKN,MAAL,GAAc,CAA/B,CAAd,CAL4B,CAKqB;AACjD,WAAKO,OAAL,GAAe,KAAf,CAN4B,CAMN;AACvB;;AAED;;;;;;;6BAIS;AACP,WAAKN,IAAL,CAAU,KAAKF,IAAf,EAAqB,KAAKC,MAA1B;AACD;;AAED;;;;;;;+BAIW;AACT,UAAIQ,QAAQZ,GAAGa,QAAH,CAAY,KAAKV,IAAjB,EAAuB,KAAKK,MAA5B,EAAoC,KAAKF,MAAzC,EAAiD,KAAKF,MAAtD,EAA8D,KAAKG,QAAnE,CAAZ;;AAEA;AACA,UAAIK,UAAU,KAAKR,MAAnB,EAA2B;AACzB,aAAKO,OAAL,GAAe,IAAf;AACD,OAFD,MAEO;AACL;AACA,aAAKL,MAAL,GAAc,KAAKA,MAAL,KAAgB,CAAhB,GAAoB,CAApB,GAAwB,KAAKF,MAA3C;;AAEA;AACA,aAAKG,QAAL,IAAiBK,KAAjB;AACD;AAGF;;AAED;;;;;;;;;mCAMwB;AAAA,UAAXE,KAAW,uEAAH,CAAG;;AACtB,aAAO,KAAKN,MAAL,CAAYO,QAAZ,CAAqB,MAArB,EAA6BD,KAA7B,EAAoCA,QAAQ,CAA5C,CAAP;AACD;;AAED;;;;;;;;gCAKY;AACV,aAAO,KAAKH,OAAZ;AACD;;;;;;kBAKYT,a","file":"BufferStorage.js","sourcesContent":["/*\r\n * @Author: zhouyou@werun \r\n * @Descriptions: 缓存区存储对象 \r\n * @TodoList: 无\r\n * @Date: 2018-10-24 09:33:50 \r\n * @Last Modified by: zhouyou@werun\r\n * @Last Modified time: 2018-10-24 11:38:08\r\n */\r\n\r\nlet fs = require(\"fs\"); // 引入文件模块依赖\r\n\r\nclass BufferStorage {\r\n\r\n  constructor(file, length) {\r\n    this.init(file, length);\r\n  }\r\n\r\n  /**\r\n   * @description 初始化缓存区\r\n   * @param {*} [file=null] 文件标识符\r\n   * @param {number} [length=0] 缓存区长度\r\n   * @memberof BufferStorage\r\n   */\r\n  init(file = null, length = 0) {\r\n    this.file = file; // 打开文件标识符\r\n    this.length = length; // 缓存区长度\r\n    this.offset = 0; // 缓存区写入数据时的偏移量\r\n    this.position = 0; // 读入文件时的初始位置\r\n    this.buffer = new Buffer.alloc(this.length * 2); // 采用双缓存区策略 \r\n    this.endFlag = false; // 判断文件是否读取完成\r\n  }\r\n\r\n  /**\r\n   * @description 重新初始化缓存区\r\n   * @memberof BufferStorage\r\n   */\r\n  reload() {\r\n    this.init(this.file, this.length);\r\n  }\r\n\r\n  /**\r\n   * @description 从文件中读取指定长度字节到缓存中\r\n   * @memberof BufferStorage\r\n   */\r\n  readFile() {\r\n    let bytes = fs.readSync(this.file, this.buffer, this.offset, this.length, this.position);\r\n\r\n    // 判断文件是否读取完成\r\n    if (bytes !== this.length) {\r\n      this.endFlag = true;\r\n    } else {\r\n      // 修改偏移量来实现不同缓存区读入\r\n      this.offset = this.offset === 0 ? 0 : this.length;\r\n\r\n      // 修正下次文件读入的起始位置\r\n      this.position += bytes;\r\n    }\r\n\r\n\r\n  }\r\n\r\n  /**\r\n   * @description 获取缓存区中的一个字符\r\n   * @param {number} [index=0] 字符的索引值\r\n   * @returns 一个字符\r\n   * @memberof BufferStorage\r\n   */\r\n  getCharacter(index = 0) {\r\n    return this.buffer.toString(\"utf8\", index, index + 1);\r\n  }\r\n\r\n  /**\r\n   * @description 文件是否读取完成\r\n   * @returns 是否完成标志\r\n   * @memberof BufferStorage\r\n   */\r\n  isFileEnd() {\r\n    return this.endFlag;\r\n  }\r\n\r\n\r\n}\r\n\r\nexport default BufferStorage;"]}